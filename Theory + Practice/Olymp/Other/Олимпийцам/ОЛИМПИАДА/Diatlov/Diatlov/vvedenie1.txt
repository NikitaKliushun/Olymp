Олимпиадное программирование в НовосибирскеВведение
Здесь собран материал, который относится не к конкретным алгоритмам, а к 
олимпиадному программированию в целом. 
Ввод-вывод
Обычно написание решения олимпиадной задачи начинается с кодирования операций с 
файлами. Мы поясним это на примере простой задачи - на входе даются два числа A 
и B, надо вывести их сумму. 
Самое очевидное решение этой задачи выглядит так: 
program Sum;

var
  A,B : Integer;

begin
  Assign(Input,'input.txt');
  Reset(Input);
  Assign(Output,'output.txt');
  Rewrite(Output);
  Read(A,B);
  Writeln(A+B);
  Close(Input);
  Close(Output);
end.



Заметьте, что в этом примере не объявляются файловые переменные, так как 
операции ввода/вывода проводятся через стандартные файлы Input и Output, которые 
есть в любой реализации Паскаля. Это позволяет также не указывать имя файловой 
переменной в вызовах функций Read() и Write(). Кроме того, в Турбо Паскале 
последние две строки кода можно опустить, так как в нем файлы Input и Output 
автоматически закрываются в конце выполнения программы. (К сожалению, к Free 
Pascal это не относится). Наконец, если вы хотите тестировать программу для 
ввода с клавиатуры, то достаточно закомментировать строки, связанные с вызовами 
Assign(), Reset(), Rewrite() и Close(), и не требуется изменять инструкции 
чтения/записи. 
В реализации более сложных задач может потребоваться разделить процесс 
выполнения на три: ввод, решение и вывод. В этом случае решение задачи "A+B" 
будет выглядеть так: 
program Sum;

var
  A,B,C : Integer;

procedure Inp;
begin
  Assign(Input,'input.txt');
  Reset(Input);
  Assign(Output,'output.txt'); 
  Rewrite(Output);
  Read(A,B);
end;

procedure Run;
begin
  C := A+B;
end;

procedure Outp;
begin
  Writeln(C);
  Close(Input);
  Close(Output);
end;

begin
  Inp;
  Run;
  Outp;
end.



Реализация таким способом решения задачи "A+B" может показаться странной, но для 
более сложных задач она часто бывает удобнее. Кроме, того, она позволяет 
использовать разные переменные цикла для чтения, решения и записи и не делать их 
глобальными. 
Символ O()
Определение. Функция f(x) называется O большим от функции g(x) (пишется 
f(x)=O(g(x))), если существуют числа C и x0 такие, что для всех x>x0 выполняется 
условие f(x)<Cg(x). 
В олимпиадном программировании часто пишут, что время работы алгоритма равно 
O(f(x)), где x - величина, связанная с размером входных данных (например, размер 
входного массива). Это фактически означает, что порядок времени работы алгоритма 
не превышает порядка функции f(x). Использование такого способа оценки времени 
работы алгоритмов связано с тем, что, в отличие от физического времени работы, 
порядок времени работы алгоритма не зависит от компилятора, процессора и 
операционной системы компьютера, на котором он выполняется. К сожалению, такая 
оценка не всегда дает правильное представление о реальном времени работы 
алгоритма; некоторые алгоритмы с плохой асимптотикой имеют маленькую константу и 
работают быстрее алгоритмов с хорошей асимптотикой и большой константой 
(например, в некоторых случаях алгоритм Эдмонда-Карпа, работающий за O(NM2), 
ищет максимальный поток в сети быстрее алгоритма "поднять и в начало" со 
временем работы O(N3), а алгоритм Дейкстры в простейшей реализации со временем 
работы O(N2+M) работает, как правило, быстрее реализации того же алгоритма с 
помощью фибоначчиевых куч, хотя асимптотика такого варианта O(Nlog N+M)). 
Известно, что 
  если f(x)=O(g(x)) и g(x)=O(h(x)), то f(x)=O(h(x)) 
  f(x)+g(x)=O(max(f(x),g(x)) 
  Cf(x)=O(f(x)), где C - константа 
  xn=O(xm), если n<=m 
  xn=O(mx) 
  mx=O(xx) 
  log x=O(x) 
  log(x!)=O(xlog x) 
  Если время работы алгоритма O(x), то алгоритм называется линейным 
  Если время работы алгоритма O(xn) для некоторого фиксированного n, то алгоритм 
  называется полиномиальным 
Асимптотическое соотношение показывает, как быстро будет расти время работы 
алгоритма при больших x, что весьма важно. Пусть, например, у нас есть два 
алгоритма, один из которых работает за время f(x)=x2, а второй за время 
g(x)=10000x. Ясно, что f(x)=O(x2), g(x)=O(x). При малых x f(x) будет намного 
меньше g(x), но уже при x=100000, f(x)=1010, а g(x)=109<f(x), и при увеличении x 
разница между этими двумя функциями будет быстро расти. 
Отсечение по времени
В большинстве задач есть ограничение по времени, и в случае его превышения за 
тест ставится 0 баллов, даже если программа в процессе перебора уже нашла 
правильный ответ. В таких случаях применяется отсечение по времени - в начале 
выполнения программы записывается текущее время, и перебор прерывается в том 
случае, если время выполнения программы превышает критическое значение; в этом 
случае выводится наилучший полученный к этому моменту результат. 
В Турбо Паскале для реализации отсечения по времени используется переменная типа 
Longint по абсолютному адресу $0:$46c; ее значение увеличивается на единицу 
каждые 55 миллисекунд: 
program TheTime_TP;

const
  CriticalTime = 4.8; {seconds}

var
   Ct : Longint absolute 0:$46c;
   Ot : Longint;

begin
  Ot := Ct + Trunc(CriticalTime*1000/55);
  ...
  while ... do
  begin
    if Ct>Ot then
      Break;
    ...
  end;
  ...
end.



В Free Pascal для реализации отсечения по времени используется функция Now() из 
модуля SysUtils; она возвращает текущее время и дату в формате TDateTime; Now() 
становится больше на единицу через 1 сутки: 
program TheTime_FP;

uses
  SysUtils;

const
  CriticalTime = 4.8; {seconds}
  CriticalD : TDateTime = CriticalTime/(24*60*60);

var
  Ot : TDateTime;

begin
  Ot := Now + CriticalTime;
  ...
  while ... do
  begin
    if Now>Ot then
      Break;
    ...
  end;
  ...
end.





      © Semyon DyatlovMail me
Interesting things 
